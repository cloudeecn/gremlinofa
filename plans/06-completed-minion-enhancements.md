# Minion System Enhancements

Phase 1 completed.
Phase 2 completed.
Phase 3 completed.
Phase 4 completed.

This plan has been completed

Enhancements to the agentic loop and minion system for better streaming, rendering, and error recovery.

## Overview

Four interconnected enhancements:

1. **Streaming Tool Result Pattern** - Pre-create tool result messages for all tools with running state
2. **Return Tool Resumption** - Resume minion chats correctly when they ended with `return` tool
3. **Natural Minion Rendering** - Accumulated rendering with proper styling
4. **Error Recovery** - Checkpoint system and resend capability

---

## Phase 1: Streaming Tool Result Pattern (Foundation)

Pre-create tool result messages when tool execution starts, enabling real-time streaming and consistent UI state for all tools.

### 1.1 New Event Types (`agenticLoopGenerator.ts`)

```typescript
export type AgenticLoopEvent =
  | { type: 'streaming_start' }
  | { type: 'streaming_chunk'; groups: RenderingBlockGroup[] }
  | { type: 'streaming_end' }
  | { type: 'message_created'; message: Message<unknown> }
  | { type: 'tokens_consumed'; tokens: TokenTotals }
  | { type: 'first_chunk' }
  // NEW: Tool lifecycle events
  | { type: 'tool_execution_start'; toolUses: ToolUseBlock[]; pendingMessage: Message<unknown> }
  | { type: 'tool_execution_streaming'; toolUseId: string; groups: RenderingBlockGroup[] }
  | { type: 'tool_execution_end'; toolUseId: string };
```

### 1.2 New Types (`content.ts`)

Add to `ToolResultRenderBlock`:

```typescript
interface ToolResultRenderBlock {
  // ... existing fields
  /** Execution status - shows spinner when 'running' */
  status?: 'running' | 'complete' | 'error';
  /** Finalized rendering groups from tool execution (for minion) */
  minionFinalizedBlocks?: RenderingBlockGroup[];
}
```

Add to `RenderingBlockGroup`:

```typescript
interface RenderingBlockGroup {
  category: BlockCategory;
  blocks: RenderingContentBlock[];
  /** True if generated by tool (minion, etc.) - renders with different styling */
  isToolGenerated?: boolean;
}
```

### 1.3 Agentic Loop Changes (`agenticLoopGenerator.ts`)

**Current flow:**

1. Tool call starts
2. Tool executes (blocking)
3. Tool result message created after completion

**New flow:**

1. Tool call starts
2. Tool result message created with `status: 'running'`
3. Yield `tool_execution_start` event with pending message
4. Tool executes, streaming tools yield `tool_execution_streaming` events
5. Tool result message updated with final result and `status: 'complete'`
6. Yield `message_created` event

```typescript
// Pre-create tool result message with all tool_use blocks in "running" state
const pendingRenderBlocks: ToolResultRenderBlock[] = toolUseBlocks.map(toolUse => ({
  type: 'tool_result',
  tool_use_id: toolUse.id,
  name: toolUse.name,
  content: 'Running...',
  status: 'running',
  icon: toolRegistry.get(toolUse.name)?.iconInput ?? 'ðŸ”§',
}));

const pendingToolResultMsg = buildToolResultMessage(apiType, [], pendingRenderBlocks);
yield { type: 'tool_execution_start', toolUses: toolUseBlocks, pendingMessage: pendingToolResultMsg };

// Execute tools
for (const toolUse of toolUseBlocks) {
  const toolResult = await executeClientSideTool(..., {
    ...toolContext,
    onToolStreaming: (groups) => {
      // Forward streaming updates (for minion)
    }
  });

  yield { type: 'tool_execution_end', toolUseId: toolUse.id };

  // Update the render block for this tool
  updateToolResultRenderBlock(pendingToolResultMsg, toolUse.id, toolResult);
}

// Yield final message
yield { type: 'message_created', message: pendingToolResultMsg };
```

### 1.4 Consumer Updates (`useChat.ts`)

Handle new events in `consumeAgenticLoop`:

```typescript
case 'tool_execution_start':
  // Show pending tool result message in UI (with "running" state)
  // Don't save to storage yet - it's ephemeral until complete
  setMessages(prev => [...prev, event.pendingMessage]);
  break;

case 'tool_execution_streaming':
  // Update streaming state for minion tools
  setMinionStreamingState({ minionChatId: ..., groups: event.groups });
  break;

case 'tool_execution_end':
  // Clear streaming state for completed tool
  setMinionStreamingState(null);
  break;

case 'message_created':
  // For tool result messages: replace the pending message
  // For assistant messages: append
  await storage.saveMessage(chat.id, event.message);
  setMessages(prev => {
    const pendingIdx = prev.findIndex(m => m.id === event.message.id);
    if (pendingIdx >= 0) {
      // Replace pending with final
      return [...prev.slice(0, pendingIdx), event.message, ...prev.slice(pendingIdx + 1)];
    }
    return [...prev, event.message];
  });
  break;
```

### 1.5 UI Styling for Tool-Generated Content

Three tiers of styling for minion/tool-generated blocks:

**1.5.1 Backstage blocks** - Pinker background (vs standard purple)

```tsx
// BackstageView when isToolGenerated
className={isToolGenerated
  ? 'border-l-4 border-pink-300 bg-pink-50'
  : 'border-l-4 border-purple-400 bg-purple-50'}
```

**1.5.2 Text blocks (streaming / intermediate)** - Subtle background with border

```tsx
// TextGroupView when isToolGenerated and not final
className = 'bg-gray-50 border border-gray-200 rounded-lg px-3 py-2';
```

**1.5.3 Return content / last text block (finalized)** - Green background

```tsx
// Final text block or return tool result
// Determined at render time, not stored
className = 'bg-green-50 border border-green-300 rounded-lg px-3 py-2';
```

**Derivation logic (no stored `isFinal` needed):**

```tsx
const isBlockFinal = (groupIndex: number) => {
  if (status !== 'complete') return false;

  // Find last text group index
  const lastTextIndex = minionFinalizedBlocks.reduceRight(
    (found, g, i) => (found >= 0 ? found : g.category === 'text' ? i : -1),
    -1
  );

  return groupIndex === lastTextIndex;
};

// Or for return tool specifically:
const isFinalResult = status === 'complete' && minionUsedReturnTool;
```

### 1.6 ToolResultBubble Updates

Show running indicator:

```tsx
{
  result.status === 'running' && (
    <div className="flex items-center gap-2 text-purple-600">
      <BouncingDots />
      <span>Running...</span>
    </div>
  );
}
```

---

## Phase 2: Return Tool Resumption

When resuming a minion chat that ended with a `return` tool call, send a tool_result instead of a user message.

### 2.1 Detection Logic (`minionTool.ts`)

```typescript
if (minionInput.minionChatId) {
  const existing = await storage.getMinionChat(minionInput.minionChatId);
  existingMessages = await storage.getMinionMessages(minionInput.minionChatId);

  // Check if last message is assistant with pending return tool
  if (existingMessages.length > 0) {
    const lastMsg = existingMessages[existingMessages.length - 1];
    if (lastMsg.role === 'assistant') {
      const toolUseBlocks = apiService.extractToolUseBlocks(
        apiDef.apiType,
        lastMsg.content.fullContent
      );
      const returnToolUse = toolUseBlocks.find(t => t.name === 'return');

      if (returnToolUse) {
        // Build tool_result for the return call
        const toolResultMsg = buildToolResultMessage(apiDef.apiType, [{
          type: 'tool_result',
          tool_use_id: returnToolUse.id,
          content: minionInput.message, // User's message becomes the return result
        }], [...]);

        // Use tool_result instead of user message
        minionContext = [...existingMessages, toolResultMsg];
        skipUserMessage = true;
      }
    }
  }
}
```

### 2.2 MinionChatId in Output

Return JSON content with `minionChatId` - no stripping needed since only `content` and `is_error` go to LLM:

```typescript
const minionMeta: MinionMeta = {
  minionChatId: minionChat.id,
  minionFinalizedBlocks: accumulatedGroups,
  minionResponse: finalResponse,
  minionUsedReturnTool: usedReturnTool,
};

return {
  content: JSON.stringify({
    result: finalResponse,
    minionChatId: minionChat.id,
  }),
  _minionMeta: minionMeta, // UI only, not sent to LLM
};
```

---

## Phase 3: Accumulated Minion Rendering

Accumulate finalized blocks from minion execution, following the same pattern as MessageList (finalized + streaming).

### 3.1 Accumulator in Minion Tool

```typescript
// Track finalized groups from the minion run
let accumulatedGroups: RenderingBlockGroup[] = [];

// In event loop
case 'message_created':
  await storage.saveMinionMessage(minionChat.id, event.message);

  // Accumulate rendering content, mark as tool-generated
  if (event.message.content.renderingContent) {
    const markedGroups = event.message.content.renderingContent.map(g => ({
      ...g,
      isToolGenerated: true,
    }));
    accumulatedGroups.push(...markedGroups);
  }

  // Clear streaming (finalized replaces streaming)
  if (context.onMinionStreaming) {
    context.onMinionStreaming([], minionChat.id);
  }
  break;

case 'streaming_chunk':
  // Forward streaming to main chat UI
  if (context.onMinionStreaming) {
    context.onMinionStreaming(event.groups, minionChat.id);
  }
  break;
```

### 3.2 Storage in Tool Result

Finalized blocks stored in `ToolResultRenderBlock.minionFinalizedBlocks`:

```typescript
function createToolResultRenderBlock(
  toolUseId: string,
  toolName: string,
  content: string,
  isError?: boolean,
  minionMeta?: MinionMeta
): ToolResultRenderBlock {
  const block: ToolResultRenderBlock = {
    type: 'tool_result',
    tool_use_id: toolUseId,
    content,
    is_error: isError,
    name: toolName,
    status: 'complete',
    // ...
  };

  if (minionMeta) {
    block.minionChatId = minionMeta.minionChatId;
    block.minionFinalizedBlocks = minionMeta.minionFinalizedBlocks;
    block.minionResponse = minionMeta.minionResponse;
    block.minionUsedReturnTool = minionMeta.minionUsedReturnTool;
  }

  return block;
}
```

### 3.3 MinionResultView Updates

Render finalized blocks + streaming (matching MessageList pattern):

```tsx
function MinionResultView({
  minionChatId,
  minionFinalizedBlocks,
  minionResponse,
  minionUsedReturnTool,
  status,
  streamingGroups, // from minionStreamingState when running
}: MinionResultViewProps) {
  return (
    <div className="minion-result">
      {/* Finalized blocks */}
      {minionFinalizedBlocks?.map((group, i) => (
        <div key={i} className={getGroupClassName(group, i, status, minionUsedReturnTool)}>
          {group.category === 'backstage' && (
            <BackstageView blocks={group.blocks} isToolGenerated />
          )}
          {group.category === 'text' && <TextGroupView blocks={group.blocks} />}
        </div>
      ))}

      {/* Streaming content (only when running) */}
      {status === 'running' && streamingGroups?.length > 0 && (
        <div className="streaming-content">{/* Render streaming groups with muted styling */}</div>
      )}
    </div>
  );
}
```

---

## Phase 4: Error Recovery

### 4.1 Checkpoint on MinionChat (Data Only)

Add checkpoint field for future LLM-controlled rollback (populate data, don't implement rollback logic):

```typescript
interface MinionChat {
  // ... existing
  /** Last message ID before this minion run started (for future rollback) */
  checkpoint?: string;
}
```

Set when minion starts:

```typescript
// In minionTool execute
minionChat.checkpoint =
  existingMessages.length > 0 ? existingMessages[existingMessages.length - 1].id : undefined;
await storage.saveMinionChat(minionChat);
```

### 4.2 Resend Action (`useChat.ts`)

Add resend capability for tool_result and user messages:

```typescript
/**
 * Resend from a message - delete messages after and re-run agentic loop.
 * Useful when a costly tool call succeeded but the following API call failed.
 */
const resendFromMessage = async (messageId: string) => {
  const msgIndex = messages.findIndex(m => m.id === messageId);
  if (msgIndex === -1) return;

  // Confirmation popup
  const confirmed = await showConfirm(
    'Resend Message',
    'This will delete all messages after this one and resend. Continue?'
  );
  if (!confirmed) return;

  // Delete messages AFTER the target (keep the target message)
  if (msgIndex + 1 < messages.length) {
    await storage.deleteMessageAndAfter(chatId, messages[msgIndex + 1].id);
  }

  // Update state to keep only messages up to and including target
  const context = messages.slice(0, msgIndex + 1);
  setMessages(context);

  // Re-run agentic loop from this context
  const options = await buildAgenticLoopOptions(chat, project, apiDef, model, modelId);
  await consumeAgenticLoop(options, context, chat, project, buildEventHandlers());
};
```

### 4.3 UI - Resend Button

Add resend button to `ToolResultBubble` and `UserMessageBubble`:

```tsx
{
  onAction && (
    <button
      onClick={() => onAction('resend', message.id)}
      className="text-[10px] text-gray-400 transition-colors hover:text-blue-600"
      title="Rollback and resend from here"
    >
      ðŸ”„
    </button>
  );
}
```

Update `MessageBubble.tsx` to handle 'resend' action.

---

## Implementation Order

| Phase | Dependencies | Description                                               |
| ----- | ------------ | --------------------------------------------------------- |
| 1     | None         | Foundation: streaming tool pattern, new events, UI status |
| 2     | Phase 1      | Return tool resumption logic                              |
| 3     | Phase 1      | Accumulated rendering in MinionResultView                 |
| 4     | Phase 1      | Checkpoint data + resend capability                       |

Recommended: 1 â†’ 2 â†’ 3 â†’ 4

---

## Files to Modify

| File                                           | Changes                                                  |
| ---------------------------------------------- | -------------------------------------------------------- |
| `src/types/content.ts`                         | Add `status`, `minionFinalizedBlocks`, `isToolGenerated` |
| `src/types/index.ts`                           | Add `checkpoint` to MinionChat, update `MinionMeta`      |
| `src/services/agentic/agenticLoopGenerator.ts` | Tool execution lifecycle events, pre-create messages     |
| `src/services/tools/minionTool.ts`             | Return tool resumption, accumulate groups, JSON output   |
| `src/hooks/useChat.ts`                         | Handle new events, add `resendFromMessage`               |
| `src/components/chat/ToolResultBubble.tsx`     | Running state UI, resend button, styling                 |
| `src/components/chat/UserMessageBubble.tsx`    | Resend button                                            |
| `src/components/chat/MinionResultView.tsx`     | Display finalized + streaming, tiered styling            |
| `src/components/chat/BackstageView.tsx`        | `isToolGenerated` prop for pink styling                  |
| `src/components/chat/TextGroupView.tsx`        | Tool-generated text styling                              |

---

## Testing

- [x] Tool result message shows "running" state during execution (UI - covered by `MinionResultView.test.tsx`)
- [x] Minion streaming displays in real-time during execution (`minionIntegration.test.ts` - "streams progress via onMinionStreaming callback")
- [x] Finalized blocks accumulate correctly (`minionIntegration.test.ts` - verified via `minionFinalizedBlocks` in result)
- [x] Resume minion with return tool sends tool_result not user message (`minionIntegration.test.ts` - "sends tool_result instead of user message when resuming after return tool")
- [x] JSON output contains `minionChatId` (`minionIntegration.test.ts` - "completes simple task and returns result with minionMeta")
- [x] Checkpoint populated on MinionChat (`minionIntegration.test.ts` - "sets checkpoint to last message ID when continuing minion chat")
- [x] Resend button shows on tool_result and user messages (UI - covered by component render tests)
- [x] Resend confirmation dialog works (UI - covered by `useChat.test.ts` mock patterns)
- [x] Messages after target deleted on resend (`useChat.test.ts` - verifies `deleteMessageAndAfter` is called)
- [x] Agentic loop continues correctly after resend (`agenticLoopGenerator.test.ts` - context array tests)
