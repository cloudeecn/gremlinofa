This plan has been completed

# Tool Streaming Generalization

## Background

### What Plans 05/06 Built

The minion system (plan 05) and enhancements (plan 06) implemented:

- Minion tool that delegates to a sub-agent agentic loop
- Return tool for explicit result signaling
- MinionChat storage with cascade deletion
- Tool option types (boolean/longtext/model) with UI
- Checkpoint system and resend capability
- Streaming tool result pattern (events, pending messages)
- Accumulated minion rendering with `isToolGenerated` styling

### Current State After Cleanup

The user removed minion-specific glue code to reduce duplication. What remains:

**Working:**

- `minionTool.ts` core logic: sub-agent agentic loop, return tool resumption, checkpoint, token accumulation — returns `_minionMeta` but nothing consumes it
- MinionChat storage CRUD, cascade deletion, export/import
- Return tool
- All simple tools (memory, js, fs)
- Agentic loop generator (normal tool execution path)
- `ToolResultStatus` on `ToolResultRenderBlock`
- `resendFromMessage` in useChat
- UI components exist: MinionResultView, MinionStreamingBar, MinionStreamingSection, ToolResultBubble

**Broken / Dead Code:**

- `yield` inside callback in `agenticLoopGenerator.ts` (~line 330) — can't yield from a callback, syntax error at runtime
- `minionStreamingStates` in useChat — declared and cleared but never populated
- `ToolContext` doesn't declare `onMinionStreaming`/`onMinionStreamingEnd` but minionTool.ts calls them (duck typing, silently no-ops)
- `isToolGenerated` used on `RenderingBlockGroup` but not declared in the type
- `_minionMeta` → `MinionRunRenderBlock` → rendering pipeline — broken, results don't display
- `ToolCallback` interface — accepted by `executeClientSideTool` but never used by any tool
- `createToolResultRenderBlock` has minion-specific `isMinionRunRenderBlock()` branch

## Problem

Minion-specific types and components make it hard to:

1. Get minion results rendering again after cleanup
2. Add streaming to other tools in the future
3. Run tool calls in parallel (requires tools as generators)
4. Maintain the codebase (duplicated types, broken wiring)

## Design

### Core Insight: Reuse Message State for Streaming

Instead of separate streaming state (`minionStreamingStates` Map), use the message itself:

1. Create tool_result message with `status: 'running'` blocks
2. Push to React state → UI renders immediately
3. Tools yield updates → update blocks in that message
4. Tool completes → set `status: 'complete'`, save to storage

**Benefits:**

- Same renderer for streaming and final display
- No separate streaming state map
- Message naturally persists when complete
- Works with parallel tools (each tool = one block in message)

### New Types

#### ToolInfoRenderBlock

Replaces minion-specific `minionInput`, `minionChatId` fields with a generic info block that any tool can use:

```typescript
export interface ToolInfoRenderBlock {
  type: 'tool_info';
  /** Input/task description sent to tool (shown in blue box) */
  input?: string;
  /** Sub-chat ID for "Copy All" functionality */
  chatId?: string;
}
```

The generic renderer shows:

- `input` → blue box with the task description
- `chatId` → "Copy All" button that fetches messages from that chat

#### Simplified ToolResultRenderBlock

```typescript
export interface ToolResultRenderBlock {
  type: 'tool_result';
  name: string;
  tool_use_id: string;
  content: string; // Final result text
  is_error?: boolean;
  status?: ToolResultStatus; // 'running' | 'complete' | 'error'
  renderedContent?: string; // Pre-rendered for display
  icon?: string;

  // Generic nested groups from tool's internal work
  renderingGroups?: RenderingBlockGroup[];
}
```

**Remove:**

- `MinionRunRenderBlock` interface
- `isMinionRunRenderBlock()` type guard
- `MinionMeta` type
- `_minionMeta` on `ToolResult`
- `ToolCallback` interface

#### Formalize isToolGenerated

Add to `RenderingBlockGroup` (currently used ad-hoc but not declared):

```typescript
export interface RenderingBlockGroup {
  category: BlockCategory;
  blocks: RenderingContentBlock[];
  /** True if generated by a tool (renders with pinker styling) */
  isToolGenerated?: boolean;
}
```

#### renderingGroups Structure (for tools with nested content)

```typescript
// Example: minion tool result
renderingGroups: [
  // Info block at start
  { category: 'backstage', blocks: [{ type: 'tool_info', input: "task text", chatId: "minion_xxx" }] },
  // Tool's internal work (marked as tool-generated for pink styling)
  { category: 'backstage', blocks: [...thinking, tool_use, tool_result...], isToolGenerated: true },
  { category: 'text', blocks: [...text...], isToolGenerated: true },
  // ...more groups from sub-agent execution...
]
// content field = final result (green box if success, red if error)
```

### Tool as Async Generator

```typescript
// Event types yielded during tool execution
export type ToolStreamEvent = { type: 'groups_update'; groups: RenderingBlockGroup[] };

// Updated execute signature
interface ClientSideTool {
  execute(
    input: Record<string, unknown>,
    toolOptions?: ToolOptions,
    context?: ToolContext
  ): AsyncGenerator<ToolStreamEvent, ToolResult>;
}
```

**Simple tools** (memory, fs, js, return): converted to `async function*` that just returns, no yields.

**Complex tools** (minion): yields `groups_update` events from inner agentic loop, returns final result with `renderingGroups` built from accumulated groups + `ToolInfoRenderBlock`.

### Agentic Loop Changes

Replace the broken yield-in-callback with proper generator consumption:

```typescript
// New/updated events
export type AgenticLoopEvent =
  | { type: 'streaming_start' }
  | { type: 'streaming_chunk'; groups: RenderingBlockGroup[] }
  | { type: 'streaming_end' }
  | { type: 'message_created'; message: Message<unknown> }
  | { type: 'tokens_consumed'; tokens: TokenTotals }
  | { type: 'first_chunk' }
  // Replace tool_execution_phase_start/streaming/end with:
  | { type: 'pending_tool_result'; message: Message<unknown> }
  | { type: 'tool_block_update'; toolUseId: string; block: Partial<ToolResultRenderBlock> };
```

Flow:

1. API returns `stop_reason: 'tool_use'`
2. Create pending tool_result message with `status: 'running'` blocks
3. Yield `pending_tool_result` → consumer adds to messages state
4. For each tool: consume generator, on `groups_update` → yield `tool_block_update`
5. Tool returns → update block with final content/status
6. Yield `message_created` with final message → consumer replaces pending

### Consumer (useChat) Changes

1. **Remove** `minionStreamingStates`, `setMinionStreamingStates`, `MinionStreamingEntry`
2. **Remove** `onToolResultCreated` handler
3. **Handle** `pending_tool_result` → add pending message to state (not saved to storage)
4. **Handle** `tool_block_update` → find block by toolUseId in pending message, update renderingGroups
5. **Handle** `message_created` for tool result → replace pending with final (save to storage)

### View Changes

**New: `ToolResultView.tsx`** — unified renderer for all tool results:

- If `renderingGroups` exists → render nested content:
  - `tool_info` blocks → blue input box + copy buttons (if `chatId`)
  - backstage/text groups → normal rendering with `isToolGenerated` pink styling
- If no `renderingGroups` → render simple `renderedContent` text
- `content` field → green box (success) or red box (error) at bottom
- `status: 'running'` → spinner/bouncing dots, auto-expand

**Delete:**

- `MinionResultView.tsx`
- `MinionStreamingBar.tsx`
- `MinionStreamingSection.tsx`

**Update:**

- `ToolResultBubble.tsx` → use `ToolResultView` for all results (remove minion/non-minion split)
- `BackstageView.tsx` `ToolResultSegment` → use `ToolResultView` for inline tool results
- `ChatView.tsx` / `MessageList.tsx` → remove `MinionStreamingSection` usage
- `components/chat/types.ts` → remove `MinionStreamingEntry`, `MinionStreamingStates`

### Future: Parallel Tool Execution

With generators, parallel execution becomes possible in a future phase:

```typescript
async function* executeToolsParallel(tools): AsyncGenerator<Event, Results> {
  const gens = tools.map(t => executeClientSideTool(t.name, t.input, ...));
  yield* mergeAsyncGenerators(gens); // Races all, yields events as they arrive
}
```

Not in scope for this plan — start with sequential execution using generators.

## Plan

### Phase 1: Type Foundation

- [ ] Add `ToolInfoRenderBlock` type to `content.ts`
- [ ] Add `'tool_info'` to `RenderingContentBlock` union
- [ ] Add `isToolGenerated?: boolean` to `RenderingBlockGroup`
- [ ] Add `renderingGroups?: RenderingBlockGroup[]` to `ToolResultRenderBlock`
- [ ] Update `categorizeBlock()` to handle `'tool_info'`
- [ ] Remove `MinionRunRenderBlock` interface
- [ ] Remove `isMinionRunRenderBlock()` function
- [ ] Remove `MinionMeta` from `index.ts`
- [ ] Remove `_minionMeta` from `ToolResult` type
- [ ] Remove `ToolCallback` interface from `index.ts`
- [ ] Remove `callback` parameter from `ClientSideTool.execute` signature
- [ ] Clean up `ToolContext` (it's correct as-is; the undeclared callbacks on minionTool will be removed in Phase 3)
- [ ] Update exports in `index.ts`

### Phase 2: Tool Generator Infrastructure

- [ ] Define `ToolStreamEvent` type in `index.ts` or `content.ts`
- [ ] Change `ClientSideTool.execute` return type to `AsyncGenerator<ToolStreamEvent, ToolResult>`
- [ ] Update `executeClientSideTool()` in `clientSideTools.ts`:
  - Remove `callback` parameter
  - Return type becomes `AsyncGenerator<ToolStreamEvent, ToolResult>`
  - Consume generator from tool, re-yield events, return final result
- [ ] Update `AgenticLoopEvent` types: replace `tool_execution_phase_start/streaming/end` with `pending_tool_result`, `tool_block_update`
- [ ] Update `agenticLoopGenerator.ts`:
  - Remove broken yield-in-callback
  - Before tool execution: create pending message with `status: 'running'` blocks, yield `pending_tool_result`
  - Consume each tool's generator, yield `tool_block_update` events on `groups_update`
  - After all tools: build final tool result message, yield `message_created`
  - Remove `ToolCallback` usage

### Phase 3: Tool Conversions

- [x] Convert `memoryTool.ts` to async generator (no yields, just return)
- [x] Convert `jsTool.ts` to async generator (no yields, just return)
- [x] Convert `returnTool.ts` to async generator (no yields, just return)
- [x] Convert `minionTool.ts` to async generator:
  - Remove `_minionMeta` from return value
  - Remove `context.onMinionStreaming` / `context.onMinionStreamingEnd` calls
  - Yield `{ type: 'groups_update', groups }` events from inner agentic loop
  - Build `renderingGroups` with `ToolInfoRenderBlock` at start (input + chatId)
  - Set result `content` to final response text
  - Return `ToolResult` with `renderingGroups` (no `_minionMeta`)
- [x] Convert `fsTool.ts` to async generator (no yields, just return)
- [x] Update `agenticLoopGenerator.ts` `createToolResultRenderBlock()`:
  - Already accepts optional `renderingGroups` parameter (done in Phase 2)

**Phase 3 Deviations:**

- Test helpers updated here (pulled forward from Phase 6) since generator conversion breaks `await tool.execute()` at runtime
- `memoryTool.test.ts`, `returnTool.test.ts`, `minionTool.test.ts`: Added `collectToolResult()` helpers, removed `@ts-nocheck`
- `minionIntegration.test.ts`: Added `collectToolResult()`, rewrote streaming test to verify `groups_update` events and `renderingGroups`, kept `@ts-nocheck` for skipped tests referencing `_minionMeta`
- `development.md` updated: `execute` signature, `renderingGroups` pattern, generator-based streaming

### Phase 4: useChat Consumer

- [x] Remove `minionStreamingStates` state and `setMinionStreamingStates`
- [x] Remove `MinionStreamingEntry` type from `useChat.ts`
- [x] Remove `onToolResultCreated` from `LoopEventHandlers`
- [x] Remove `minionStreamingStates` from `UseChatReturn`
- [x] Update `consumeAgenticLoop()`:
  - Handle `pending_tool_result` → add pending message to React state (not saved)
  - Handle `tool_block_update` → update renderingGroups on the matching block in pending message
  - Handle existing `message_created` → for tool result messages, replace pending with final
  - Remove old `tool_execution_start/streaming/end` handling
- [x] Update `buildEventHandlers()` — remove `onToolResultCreated`
- [x] Remove `MinionStreamingEntry` and `MinionStreamingStates` from `components/chat/types.ts`

**Phase 4 Deviations:**

- `MinionStreamingSection.tsx` inlined the removed types to stay compilable (dead code, scheduled for Phase 5 deletion)
- `ChatView.tsx` and `MessageList.tsx` updated to remove `minionStreamingStates` prop plumbing
- `onMessageSaved` handler in `buildEventHandlers()` uses ID-based replacement (`findIndex` by message ID) to replace pending messages. The pending and final messages share the same ID (assigned in `agenticLoopGenerator.ts`).
- Inline event handlers in pending state resolution useEffect also updated with `onPendingToolResult`/`onToolBlockUpdate` stubs

### Phase 5: View Unification

- [x] Create `ToolResultView.tsx`:
  - Accept `ToolResultRenderBlock` as prop
  - If `renderingGroups` exists:
    - Render `tool_info` blocks (blue input box, copy buttons if chatId)
    - Render nested backstage/text groups with `isToolGenerated` styling
  - Render result (green box if success, red if error) from `content`
  - Handle `status: 'running'` with spinner/dots, auto-expand
  - Handle `status: 'complete'` with collapsible, default collapsed
- [x] Delete `MinionResultView.tsx`
- [x] Delete `MinionStreamingBar.tsx`
- [x] Delete `MinionStreamingSection.tsx`
- [x] Update `ToolResultBubble.tsx`:
  - Remove minion/non-minion split logic
  - Use `ToolResultView` for all tool results (results with `renderingGroups` get expanded view, others get simple view)
- [x] Update `BackstageView.tsx` `ToolResultSegment`:
  - Delegate to `ToolResultView` for all tool results (handles both simple and complex)
- [x] Update `MessageList.tsx`:
  - Already clean from Phase 4 (no MinionStreamingSection references)
- [x] Update `ChatView.tsx`:
  - Already clean from Phase 4 (no minionStreamingStates references)
- [x] Update `MessageListProps` in `components/chat/types.ts`:
  - Already clean from Phase 4 (no minionStreamingStates prop)

**Phase 5 Deviations:**

- `MessageList.tsx`, `ChatView.tsx`, and `types.ts` required no changes — Phase 4 already removed all `minionStreamingStates` plumbing
- `BackstageView.ToolResultSegment` delegates to `ToolResultView` for all results (not just those with `renderingGroups`), simplifying the code and keeping rendering consistent
- `MinionResultView.test.tsx` replaced with `ToolResultView.test.tsx` (25 tests covering simple results, complex results with renderingGroups, running/complete states, tool_info blocks, copy buttons, error styling)
- `development.md` updated: removed dead code references to `MinionStreamingSection`/`MinionStreamingBar`, updated Minion Chat Display section to reference `ToolResultView`

### Phase 6: Cleanup & Tests

- [x] Update `minionIntegration.test.ts`:
  - Remove `@ts-nocheck` and `_minionMeta` assertions
  - Rewrite 4 skipped tests to verify `renderingGroups` with `ToolInfoRenderBlock`
  - Test generator yields `groups_update` events (already done in Phase 3)
- [x] Update `minionTool.test.ts`:
  - Already updated in Phase 3 with `collectToolResult()` helper
- [x] Delete or replace `MinionResultView.test.tsx` with `ToolResultView` tests
  - Already done in Phase 5 (25 tests)
- [x] Update `agenticLoopGenerator.test.ts`:
  - Remove `@ts-nocheck`, delete obsolete `suspended` status test
  - Fix `breakLoop.status` references (field removed)
- [x] Update `development.md`:
  - Fix stale `breakLoop: { status: 'complete' }` → `breakLoop: { returnValue }`
  - Remove `suspended` from `AgenticLoopResult` doc
  - No other stale references (earlier phases already cleaned up)
- [x] Verify backward compatibility: `ToolResultView` checks `renderingGroups` presence; old messages without it get simple rendering. Extra properties ignored.
- [x] Run `npm run format:silent && npm run verify` then `npm run test:silent`

**Phase 6 Deviations:**

- `agenticLoopGenerator.test.ts` also needed cleanup (not listed in original plan): removed `@ts-nocheck`, deleted `suspended` test, fixed `breakLoop.status` references
- `mockToolGenerator` in both test files needed proper return type annotations after `@ts-nocheck` removal
- Return tool integration test needed `buildToolResultMessage` mock (agentic loop uses it to build the tool result message before breakLoop)

## File Changes Summary

| File                                             | Change                                                                                                                   |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| `src/types/content.ts`                           | Add ToolInfoRenderBlock, isToolGenerated on group, renderingGroups on ToolResultRenderBlock, remove MinionRunRenderBlock |
| `src/types/index.ts`                             | Remove MinionMeta, \_minionMeta, ToolCallback. Add ToolStreamEvent. Update ClientSideTool.execute signature              |
| `src/services/tools/clientSideTools.ts`          | Remove callback param, handle generator return type                                                                      |
| `src/services/agentic/agenticLoopGenerator.ts`   | New events, generator consumption, remove broken callback, remove minionMeta from createToolResultRenderBlock            |
| `src/services/tools/memoryTool.ts`               | Convert to async generator                                                                                               |
| `src/services/tools/jsTool.ts`                   | Convert to async generator                                                                                               |
| `src/services/tools/returnTool.ts`               | Convert to async generator                                                                                               |
| `src/services/tools/minionTool.ts`               | Convert to async generator, remove \_minionMeta, yield groups_update, build renderingGroups                              |
| `src/services/tools/fsTool.ts`                   | Convert to async generator                                                                                               |
| `src/hooks/useChat.ts`                           | Remove minionStreamingStates, handle new events                                                                          |
| `src/components/chat/ToolResultView.tsx`         | **CREATE** — unified renderer                                                                                            |
| `src/components/chat/MinionResultView.tsx`       | **DELETE**                                                                                                               |
| `src/components/chat/MinionStreamingBar.tsx`     | **DELETE**                                                                                                               |
| `src/components/chat/MinionStreamingSection.tsx` | **DELETE**                                                                                                               |
| `src/components/chat/ToolResultBubble.tsx`       | Use ToolResultView, remove minion split                                                                                  |
| `src/components/chat/BackstageView.tsx`          | Use ToolResultView in ToolResultSegment                                                                                  |
| `src/components/chat/ChatView.tsx`               | Remove minionStreamingStates                                                                                             |
| `src/components/chat/MessageList.tsx`            | Remove MinionStreamingSection                                                                                            |
| `src/components/chat/types.ts`                   | Remove MinionStreamingEntry/States                                                                                       |

## Risks & Mitigations

1. **Old saved messages with MinionRunRenderBlock fields**: The view should fall back gracefully — `renderingGroups` won't exist on old messages, so `ToolResultView` shows simple `renderedContent` text. The old minion-specific fields are just ignored (extra properties on the object).

2. **Parallel tool execution complexity**: Not in scope. Start with sequential execution using generators. The generator infrastructure enables future parallel execution via `mergeAsyncGenerators`.

3. **State management complexity**: The pending-message approach keeps state simple. The message IS the source of truth, whether streaming or complete. No separate streaming state map to synchronize.

4. **fsTool.ts not in staged files**: The fs tool wasn't listed in the 44 staged files but needs the same generator conversion. It's a simple conversion (no yields).
