/**
 * Rendering content types for interleaved thinking/tool-use blocks.
 * These are API-agnostic types used for UI rendering.
 */

/** Stop reasons for messages - extensible for future providers */
export type MessageStopReason =
  | 'end_turn' // Normal completion
  | 'max_tokens' // Hit token limit
  | 'stop_sequence' // Hit stop sequence
  | 'error' // Error during generation
  | 'cancelled' // User cancelled
  | (string & {}); // Future-proof: allow any string from new providers

/** Block category for grouping */
export type BlockCategory = 'backstage' | 'text' | 'error';

/** Pre-grouped blocks stored in message */
export interface RenderingBlockGroup {
  category: BlockCategory;
  blocks: RenderingContentBlock[];
  /** True if generated by a tool (renders with distinct styling) */
  isToolGenerated?: boolean;
}

/** Generic rendering block types - API agnostic */
export type RenderingContentBlock =
  | ThinkingRenderBlock
  | TextRenderBlock
  | WebSearchRenderBlock
  | WebFetchRenderBlock
  | ToolUseRenderBlock
  | ToolResultRenderBlock
  | ToolInfoRenderBlock
  | ErrorRenderBlock;

/** Thinking block - just the thinking text */
export interface ThinkingRenderBlock {
  type: 'thinking';
  thinking: string;
}

/** Web search with results (titles and URLs only, no snippets to save storage) */
export interface WebSearchRenderBlock {
  type: 'web_search';
  id: string; // Tool use ID for matching results to searches
  query: string;
  results: WebSearchResult[];
}

export interface WebSearchResult {
  title: string;
  url: string;
  // No snippet - save storage space
}

/** Web fetch (URL and title only, no content to save storage) */
export interface WebFetchRenderBlock {
  type: 'web_fetch';
  url: string;
  title?: string;
  // No content - save storage space
}

/** Text block - markdown with citation <a> tags pre-inserted */
export interface TextRenderBlock {
  type: 'text';
  text: string; // Raw markdown with citation <a> tags only (not pre-rendered markdown)
}

/** Tool use block - client-side tool invocation */
export interface ToolUseRenderBlock {
  type: 'tool_use';
  id: string;
  name: string;
  input: Record<string, unknown>;
  /** Pre-rendered input for display (persisted at message save time) */
  renderedInput?: string;
  /** Icon for this tool invocation (persisted at message save time) */
  icon?: string;
}

/** Tool result execution status */
export type ToolResultStatus = 'pending' | 'running' | 'complete' | 'error';

/** Tool result block - result from client-side tool execution */
export interface ToolResultRenderBlock {
  type: 'tool_result';
  name: string;
  tool_use_id: string;
  content: string;
  is_error?: boolean;

  /** Pre-rendered content for display (persisted at message save time) */
  renderedContent?: string;
  /** Icon for this tool result (persisted at message save time) */
  icon?: string;
  /** Execution status - shows spinner when 'running' */
  status?: ToolResultStatus;

  /** Nested rendering groups from tool's internal work (e.g., minion sub-agent) */
  renderingGroups?: RenderingBlockGroup[];
  /** Token/cost totals incurred by this tool call (e.g., minion sub-agent API costs) */
  tokenTotals?: TokenTotals;
}

/** Info block for tool context (input description, sub-chat references) */
export interface ToolInfoRenderBlock {
  type: 'tool_info';
  /** Input/task description sent to tool (shown in info box) */
  input?: string;
  /** Sub-chat ID for "Copy All" functionality */
  chatId?: string;
  /** Persona name for namespaced minions (omitted for default persona) */
  persona?: string;
  /** Display name override for persona (set by LLM via displayName parameter) */
  displayName?: string;
  /** API definition ID used for this minion call */
  apiDefinitionId?: string;
  /** Model ID used for this minion call */
  modelId?: string;
}

/**
 * Accumulated token/cost totals across iterations.
 * Used to track costs from tool calls (e.g., minion sub-agent).
 * Adding this here (content.ts has no imports) avoids circular deps.
 */
export interface TokenTotals {
  inputTokens: number;
  outputTokens: number;
  reasoningTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  webSearchCount: number;
  cost: number;
  costUnreliable: boolean;
}

/** Error block */
export interface ErrorRenderBlock {
  type: 'error';
  message: string;
  stack?: string;
  status?: number;
}

/**
 * Categorize a block by its type.
 */
export function categorizeBlock(block: RenderingContentBlock): BlockCategory {
  switch (block.type) {
    case 'thinking':
    case 'web_search':
    case 'web_fetch':
    case 'tool_use':
    case 'tool_result':
    case 'tool_info':
      return 'backstage';
    case 'text':
      return 'text';
    case 'error':
      return 'error';
  }
}

/**
 * Group and consolidate blocks for efficient rendering.
 * - Continuous blocks of the same category are grouped together
 * - Continuous text blocks are merged into a single text block
 */
export function groupAndConsolidateBlocks(blocks: RenderingContentBlock[]): RenderingBlockGroup[] {
  const groups: RenderingBlockGroup[] = [];
  let currentGroup: RenderingBlockGroup | null = null;

  for (const block of blocks) {
    const category = categorizeBlock(block);

    if (!currentGroup || currentGroup.category !== category) {
      // Start new group
      currentGroup = { category, blocks: [block] };
      groups.push(currentGroup);
    } else {
      // Continue current group
      if (category === 'text' && block.type === 'text') {
        // Consolidate: merge text into previous text block
        const lastBlock = currentGroup.blocks[currentGroup.blocks.length - 1];
        if (lastBlock.type === 'text') {
          lastBlock.text += block.text;
        } else {
          currentGroup.blocks.push(block);
        }
      } else {
        currentGroup.blocks.push(block);
      }
    }
  }

  return groups;
}
